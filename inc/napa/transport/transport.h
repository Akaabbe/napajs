#pragma once

#include <napa/transport/transport-context.h>
#include <napa/v8-helpers.h>

namespace napa {
namespace transport {

    /// <summary> Register a Transportable object wrap with transport. </summary>
    /// <param name="constructor"> Constructor of wrap type. </param>
    /// <remarks> 'napajs/lib/transport/transport' is required instead of 'napajs/lib/transport' to avoid circular dependency on addon. </remarks>
    inline void Register(v8::Local<v8::Function> constructor) {
        constexpr int argc = 1;
        v8::Local<v8::Value> argv[argc] = { constructor };
        (void)v8_helpers::Call("napajs/lib/transport/transport", "register", argc, argv);
    }

    /// <summary> Marshall an object with transport context. C++ modules can use this helper function to marshall its members. </summary>
    /// <param name="object"> Object to marshall, it can be built-in JavaScript types or object implements napajs.transport.Transportable. </param>
    /// <param name="transportContextWrap"> TransportContextWrap to save shareable states if any. </param>
    /// <returns> Payload in V8 string of marshalled object. </summary>
    /// <remarks> 'napajs/lib/transport/transport' is required instead of 'napajs/lib/transport' to avoid circular dependency on addon. </remarks>
    inline v8::MaybeLocal<v8::String> Marshall(v8::Local<v8::Value> object, v8::Local<v8::Object> transportContextWrap) {
        constexpr int argc = 2;
        v8::Local<v8::Value> argv[argc] = { object, transportContextWrap };
        return v8_helpers::MaybeCast<v8::String>(v8_helpers::Call("napajs/lib/transport/transport", "marshall", argc, argv));
    }

    /// <summary> Marshall an object with transport context. C++ modules can use this helper function to marshall its members. </summary>
    /// <param name="object"> Object to marshall, it can be built-in JavaScript types or object implements napajs.transport.Transportable. </param>
    /// <param name="transportContext"> TransportContext to save shareable states if any. </param>
    /// <returns> Payload in V8 string of marshalled object. </summary>
    /// <remarks> 'napajs/lib/transport/transport' is required instead of 'napajs/lib/transport' to avoid circular dependency on addon. </remarks>
    inline v8::MaybeLocal<v8::String> Marshall(v8::Local<v8::Value> object, napa::transport::TransportContext* transportContext) {
        constexpr int argc = 1;
        v8::Local<v8::Value> argv[argc] = { v8_helpers::PtrToV8Uint32Array(v8::Isolate::GetCurrent(), transportContext) };
        auto transportContextWrap = v8_helpers::NewInstance("napajs/bin/addon", "TransportContextWrap", argc, argv).ToLocalChecked();
        return Marshall(object, transportContextWrap);
    }

    /// <summary> Unmarshall a payload with transport context. C++ modules can use this helper function to unmarshall its members. </summary>
    /// <param name="payload"> Payload to unmarshall, it is plain JS object generated by transport.marshallSingle. </param>
    /// <param name="transportContextWrap"> TransportContextWrap to load shareable states if any. </param>
    /// <returns> Unmarshalled V8 value from payload. </summary>
    /// <remarks> 'napajs/lib/transport/transport' is required instead of 'napajs/lib/transport' to avoid circular dependency on addon. </remarks>
    inline v8::MaybeLocal<v8::Value> Unmarshall(v8::Local<v8::Value> payload, v8::Local<v8::Object> transportContextWrap) {
        constexpr int argc = 2;
        v8::Local<v8::Value> argv[argc] = { payload, transportContextWrap };
        return v8_helpers::Call("napajs/lib/transport/transport", "unmarshall", argc, argv);
    }

    /// <summary> Unmarshall a payload with transport context. C++ modules can use this helper function to unmarshall its members. </summary>
    /// <param name="payload"> Payload to unmarshall, it is plain JS object generated by transport.marshallSingle. </param>
    /// <param name="transportContext"> TransportContext to load shareable states if any. </param>
    /// <returns> Unmarshalled V8 value from payload. </summary>
    /// <remarks> 'napajs/lib/transport/transport' is required instead of 'napajs/lib/transport' to avoid circular dependency on addon. </remarks>
    inline v8::MaybeLocal<v8::Value> Unmarshall(v8::Local<v8::Value> payload, const napa::transport::TransportContext* transportContext) {
        constexpr int argc = 1;
        v8::Local<v8::Value> argv[argc] = { v8_helpers::PtrToV8Uint32Array(v8::Isolate::GetCurrent(), transportContext) };
        auto transportContextWrap = v8_helpers::NewInstance("napajs/bin/addon", "TransportContextWrap", argc, argv).ToLocalChecked();
        return Unmarshall(payload, transportContextWrap);
    }
}
}